# peppy Copyright (c) 2006-2010 Rob McMullen
# Licenced under the GPLv2; see http://peppy.flipturn.org for more info
import os, shutil, time, new, re

import wx
import wx.stc
from wx.lib.pubsub import Publisher

from peppy.third_party.pubsub import pub

from peppy.majormodematcher import MajorModeMatcherDriver

from peppy.major import *
from peppy.jobcontrol import *
from peppy.lib.autoindent import *
from peppy.lib.foldexplorer import *
import peppy.lib.vimutil as vim
import peppy.lib.emacsutil as emacs
import peppy.lib.kateutil as kate

from peppy.editra import *
from peppy.editra.stcmixin import *

from peppy.paragraph import *


class FundamentalSTC(EditraSTCMixin, PeppySTC):
    """Subclass of PeppySTC providing the Editra mixin
    
    Needed for the Editra styling dialog.  FIXME: perhaps move the editra stuff
    right into PeppySTC?
    """
    # Need these defined as None here for the style editor
    stc_lexer_id = None
    stc_syntax_style_specs = None
    stc_extra_properties = None
    stc_keywords = None
    
    def __init__(self, parent, *args, **kwargs):
        PeppySTC.__init__(self, parent, *args, **kwargs)
        EditraSTCMixin.__init__(self, wx.GetApp().fonts.getStyleFile())


class FundamentalMode(FoldExplorerMixin, EditraSTCMixin,
                      PeppySTC, MajorMode, JobControlMixin):
    """Major mode for editing generic text files.
    
    This is the most generic major mode used for editing text files.  This uses
    a L{PeppySTC} as the editing window, and is linked to a L{Buffer} object
    that in turn is linked to the backend storage of a L{PeppyBaseSTC}.
    
    All major modes that are edit text using an STC should be subclasses of
    this mode.  Major modes that provide editing windows that aren't an STC
    (like the HexEdit view or an image viewer) will not be subclasses of
    this mode; rather, they will be subclasses of L{MajorMode} and will only
    use an STC as the backend storage within the L{Buffer} attribute that is
    associated with every major mode.
    
    The STC uses the Editra system for styling text and fonts; it is based
    on matching the filename or extension with values from its database.
    Documentation on the Editra interface is forthcoming.
    
    C{FundamentalMode} is a subclass of L{PeppySTC}, so all of the STC methods
    are availble here for user interfacing.  In addition, some mixins are
    used, like the L{BraceHighlightMixin} to provide language customizable
    brace highlighting, and the L{StandardParagraphMixin} used to determine
    the start and end of a paragraph based on the major mode.
    
    Two mixins in particular will need attention when subclassing
    FundamentalMode for new types of text files: L{StandardReturnMixin} and
    L{StandardReindentMixin}.  The L{StandardReturnMixin} provides handling
    for the return key and indenting the following line to the correct tab
    stop.  The L{StandardReindentMixin} is used to indent a line to its proper
    column based on the language supported by the major mode.  FundamentalMode
    subclasses should override both of these classes and provide them as
    mixins in order to customize the major mode.
    
    Because the L{FundamentalMode} serves as the base class for all
    text editing modes, there are many defaults specified in the
    L{default_classprefs} class attribute.  These defaults are based on
    the L{ClassPrefs} metaclass that associates keywords with values and
    serializes them to the peppy configuration file.  ClassPrefs are a
    transparent way to handle the application preferences, and you'll find
    them used all over peppy.  But, as their name suggests, ClassPrefs belong
    to the class, not the instance, so this is not for instance variable
    storage.  See the L{ClassPrefs} documentation for more information.
    """
    keyword = 'Fundamental'
    
    #: If the editra file_type (defined as the LANG_* keywords in the editra source file editra.in/syntax/synglob.py) doesn't match the class attribute 'keyword', specify the editra file type here.  In other words, None here means that the editra file_type *does* match the keyword
    editra_synonym = None
    
    # For default modes, the next four stc_* class attributes are autogenerated
    # from the Editra syntax source and placed in peppy/editra/style_specs.py
    # file.  For custom modes, you should specify these values here.
    
    #: STC Lexer ID is an integer value that controls which lexer is used
    stc_lexer_id = wx.stc.STC_LEX_NULL

    #: Editra-style syntax style list.  It is a list of tuples, see one of the language-specific files in editra.in/syntax/ and use the SyntaxSpec function's return value is the model of this class attribute.  The only difference is that you should use the actual wx.stc.STC_* variables instead of text versions
    stc_syntax_style_specs = None
    
    #: Editra-style extra properties list. It is a list of tuples, see one of the language-specific files in editra.in/syntax/ and use the Properties function's return value is the model of this class attribute.
    stc_extra_properties = None
    
    # : Editra-style keywords list.  It is a list of tuples, see one of the language-specific files in editra.in/syntax/ and use the Keywords function's return value is the model of this class attribute.
    stc_keywords = None

    #: Default comment characters in case the Editra styling database doesn't have any information about the mode
    start_line_comment = ''
    end_line_comment = ''

    #: If the language allows multiple sets of characters to start comments, the entire list of allowed comment-start characters is defined here.  start_line_comment then becomes the preferred comment start type
    start_line_comment_list = ''
    
    #: STC Marker number used for bookmarks
    bookmark_marker_number = 1
    
    #: Default characters that end a word and signal the spell checker
    word_end_chars = ' .!?\'\"'

    #: Default class preferences that relate to all instances of this major mode
    default_classprefs = (
        BoolParam('use_tab_characters', False,
                  'True: insert tab characters when tab is pressed.  False: insert the equivalent number of spaces instead.', local=True),
        IntParam('tab_size', 8, 'Number of spaces in each expanded tab', local=True),
        IntParam('indent_size', 4, 'Number of spaces in each indent level', local=True),
        IndexChoiceParam('tab_highlight_style',
                         ['ignore', 'inconsistent', 'mixed', 'spaces are bad', 'tabs are bad'],
                         1, 'Highlight bad intentation', local=True),
        BoolParam('line_numbers', True, 'Show line numbers in the margin?', local=True),
        IntParam('line_number_margin_width', 40, 'Margin width in pixels', local=True),
        BoolParam('symbols', False, 'Show symbols margin', local=True),
        IntParam('symbols_margin_width', 16, 'Symbols margin width in pixels', local=True),
        BoolParam('folding', False, 'Show the code folding margin?', local=True),
        IntParam('folding_margin_width', 16, 'Code folding margin width in pixels', local=True),
        BoolParam('wrapping', False, 'If set, use line wrapping; otherwise show horizontal scrollbars', local=True),
        BoolParam('word_wrap', False, 'If set, wrap lines at word boundries; otherwise wrap at right margin', local=True),
        BoolParam('backspace_unindents', True, local=True),
        BoolParam('indentation_guides', True, 'Show indentation guides at multiples of the indent_size', local=True),
        IntParam('highlight_column', 30, 'Column at which to highlight the indention guide.', local=True),
        IntParam('edge_column', 80, 'Column at which to show the edge (i.e. long line) indicator', local=True),
        KeyedIndexChoiceParam('edge_indicator',
                              [(wx.stc.STC_EDGE_NONE, 'none'),
                               (wx.stc.STC_EDGE_LINE, 'line'),
                               (wx.stc.STC_EDGE_BACKGROUND, 'background'),
                               ], 'line', help='Long line indication mode', local=True),
        IntParam('caret_blink_rate', 0, help='Blink rate in milliseconds or 0 to stop blinking', local=True),
        IndexChoiceParam('caret_width',
                         [(1, '1 Pixel'), (2, '2 Pixels'), (3, '3 Pixels'),],
                         2, help='Caret width in pixels', local=True),
        BoolParam('caret_line_highlight', False, help='Highlight the line containing the cursor?', local=True),
        BoolParam('view_eol', False, 'Show line-ending cr/lf characters?', local=True),
        KeyedIndexChoiceParam('view_whitespace',
                              [(wx.stc.STC_WS_INVISIBLE, 'none'),
                               (wx.stc.STC_WS_VISIBLEALWAYS, 'visible'),
                               (wx.stc.STC_WS_VISIBLEAFTERINDENT, 'after indent'),
                               ], 'none', help='Visible whitespace mode', local=True),
        IntParam('font_zoom', 0, 'Change the text size relative to the standard font size', local=True),
        BoolParam('spell_check', True, 'Spell check the document (if pyenchant is available)'),
        BoolParam('spell_check_strings_only', True, 'Only spell check strings and comments'),
        IntParam('vim_settings_lines', 20, 'Number of lines from start or end of file to search for vim modeline comments'),
        BoolParam('case_sensitive_search', False, 'Case of search string must match exactly if True; otherwise mixed case requires exact match and lower case matches all', local=True),
        BoolParam('whole_word_search', False, 'Whole word between common separators must match if True; Otherwise matches every substring', local=True),
        BoolParam('case_matching_replace', True, 'Case will be modified to match if True; otherwise case will be left as was found', local=True),
        StrParam('keyword_set_0', "", 'Space separated list of keywords used for scintilla keyword set 0', hidden=True),
        StrParam('keyword_set_1', "", 'Space separated list of keywords used for scintilla keyword set 1', hidden=True),
        StrParam('keyword_set_2', "", 'Space separated list of keywords used for scintilla keyword set 2', hidden=True),
        StrParam('keyword_set_3', "", 'Space separated list of keywords used for scintilla keyword set 3', hidden=True),
        StrParam('keyword_set_4', "", 'Space separated list of keywords used for scintilla keyword set 4', hidden=True),
        StrParam('keyword_set_5', "", 'Space separated list of keywords used for scintilla keyword set 5', hidden=True),
        StrParam('keyword_set_6', "", 'Space separated list of keywords used for scintilla keyword set 6', hidden=True),
        StrParam('keyword_set_7', "", 'Space separated list of keywords used for scintilla keyword set 7', hidden=True),
        )
    
    autoindent = NullAutoindent()
    paragraph_cls = ParagraphInfo

    def __init__(self, parent, wrapper, buffer, frame):
        """Create the STC and apply styling settings.

        Everything that subclasses from FundamentalMode will use an
        STC instance for displaying the user interaction window.
        """
        MajorMode.__init__(self, parent, wrapper, buffer, frame)
        start = time.time()
        self.dprint("starting PeppySTC at %0.5fs" % start)
        PeppySTC.__init__(self, parent, refstc=self.buffer.stc)
        self.dprint("PeppySTC done in %0.5fs" % (time.time() - start))
        EditraSTCMixin.__init__(self, wx.GetApp().fonts.getStyleFile())
        self.dprint("EditraSTCMixin done in %0.5fs" % (time.time() - start))
        
        self.createCommentRegex()
        
        self.spell = None
        self.calltip_driver = False
        self.calltip_pos = -1

    @classmethod
    def preferThreadedLoading(cls, url):
        # For Fundamental mode and its descendants (unless overridden),
        # threaded loading is disabled by default when loading from the local
        # filesystem
        if url.scheme == "file":
            return False
        return True
    
    def isMacroProcessingAvailable(self):
        return True


    def createWindowPostHook(self):
        """Apply settings for the STC"""
        start = time.time()
        self.applySettings()
        self.dprint("applySettings done in %0.5fs" % (time.time() - start))

    @classmethod
    def verifyMimetypeHook(cls, mimetype):
        """Verify that the mimetype is text/plain.
        
        The class attribute mimetype is not used so that subclasses that extend
        Fundamental but forget to declare a MIME type won't also get added to
        the list of modes that handle text/plain.
        """
        # check for the class here so that subclasses don't automatically also
        # get associated with text/plain
        if cls == FundamentalMode:
            return mimetype == 'text/plain'
        return False
    
    @classmethod
    def verifyLanguage(cls, header):
        lines = header.splitlines(True)
        likely_count = 0
        non_comment_lines = ""
        for line in lines:
            line = line.strip()
            if cls.start_line_comment:
                if line.startswith(cls.start_line_comment):
                    likely_count += 1
                else:
                    non_comment_lines += line
        brace_count = 0
        lines = non_comment_lines.splitlines(False)
        for line in lines:
            line = line.strip()
            if line.endswith("{"):
                brace_count += 1
            elif line.endswith("}"):
                brace_count += 1
        if cls.stc_lexer_id == wx.stc.STC_LEX_CPP:
            if brace_count == 0:
                return 0
            likely_count += brace_count
        for index in range(0, 8):
            setname = "keyword_set_%d" % index
            keywords = cls.classprefs._get(setname)
            if keywords:
                #dprint(keywords)
                for keyword in keywords.split():
                    if keyword in non_comment_lines:
                        likely_count += 1
        return likely_count
    
    def save(self, url=None):
        """Wrapper around L{MajorMode.save} to change the major mode after
        saving an FundamentalMode file.
        
        L{savePostHook} is not used because that is supposed to be for user's
        subclasses and not system utilities.
        """
        success = MajorMode.save(self, url)
        if success and self.__class__ == FundamentalMode:
            newmodecls = self.rescanForMajorModeChange()
            if newmodecls != FundamentalMode:
                self.dprint("Changing to %s" % newmodecls)
                self.frame.changeMajorMode(newmodecls)
            else:
                self.dprint("No major mode match found; attempting to set Editra styling")
                self.applySettings()
        return success
    
    def rescanForMajorModeChange(self):
        """Call the MajorModeMatcherDriver to determine the major mode
        
        This uses the current text of the major mode as the header text, rather
        than having the MajorModeMatcherDriver load bytes from the URL.
        """
        # header must be in bytes, not unicode
        header = self.GetText().encode('utf-8')
        newcls = MajorModeMatcherDriver.match(self.buffer, header=header)
        return newcls
    
    def createEventBindingsPostHook(self):
        self.Bind(wx.stc.EVT_STC_MARGINCLICK, self.OnMarginClick)
        
    def createListenersPostHook(self):
        self.addModifyCallback(self.spellCheckUpdate)

    def createStatusIcons(self):
        linesep = self.getLinesep()
        if linesep == '\r\n':
            icon = "icons/windows.png"
            tooltip = _("DOS/Windows line endings")
        elif linesep == '\r':
            icon = "icons/apple.png"
            tooltip = _("Old-style Apple line endings")
        else:
            icon = "icons/tux.png"
            tooltip = _("Unix line endings")
        if self.refstc.encoding:
            tooltip += "\nEncoding: %s" % self.refstc.encoding
        self.status_info.addIcon(icon, tooltip)
        if self.spell and self.spell.hasDictionary():
            self.status_info.addIcon("icons/book_open.png", "Dictionary available for %s" % self.spell.getLanguage())
    
    def isTemplateNeeded(self):
        """Return True if a template file should be loaded.
        
        If a new file is being created, a template containing boilerplate text
        can be loaded in its place.  This method determines if a template is
        needed or not, and is called by the project plugin.
        """
        if self.GetLength() == 0 and not vfs.exists(self.buffer.url):
            # Only if we are creating a new file should the template used
            return True
        return False
    
    def setTextFromTemplate(self, template_text):
        """The companion method to L{isTemplateNeeded} that is used to set the
        text in the editor to the template text.
        
        This also marks the file as modified so the user knows that it hasn't
        yet been saved.
        """
        self.resetText(template_text)
        self.buffer.setInitialStateIsModified()
    
    def getProperties(self):
        # Use the MajorMode's getProperties instead of the stub from
        # STCInterface
        return MajorMode.getProperties(self)

    def applySettings(self):
        start = time.time()
        self.dprint("starting applySettings")
        self.applyDefaultSettings()
        Publisher().sendMessage('fundamental.default_settings_applied', self)
        self.dprint("applyDefaultSettings done in %0.5fs" % (time.time() - start))
        
        self.applyFontStyling()
        self.applyEditraStyling()
        self.dprint("applyEditraStyling done in %0.5fs" % (time.time() - start))
        self.has_stc_styling = True
        self.applyFileLocalComments()
        self.setSpelling()
        self.dprint("applySettings returning in %0.5fs" % (time.time() - start))
    
    def applyFontStyling(self):
        """Apply the default fonts to the Editra styling system
        
        """
        self.SetStyleFont(wx.GetApp().fonts.classprefs.primary_editing_font)
        self.SetStyleFont(wx.GetApp().fonts.classprefs.secondary_editing_font, False)
    
    def applyEditraStyling(self):
        # Here's the global hack to fix the problem the first time styles are
        # modified by the style dialog.
        if self.global_style_set and self.global_style_set != self.style_set:
            self.style_set = self.global_style_set
            self.dprint("Changing style to global style %s" % self.style_set)
        self.ConfigureLexer(self.keyword)

    def applyDefaultSettings(self):
        # We use our own right click popup menu, so disable the builtin
        self.UsePopUp(0)
        
        # turn off symbol margin
        if self.locals.symbols:
            self.SetMarginWidth(1, self.locals.symbols_margin_width)
        else:
            self.SetMarginWidth(1, 0)

        # turn off folding margin
        if self.locals.folding:
            self.SetMarginWidth(2, self.locals.folding_margin_width)
        else:
            self.SetMarginWidth(2, 0)

        self.SetProperty("fold", "1")
        self.SetBackSpaceUnIndents(self.locals.backspace_unindents)
        self.SetHighlightGuide(self.locals.highlight_column)

        self.setWordWrap()
        self.setLineNumbers()
        self.setFolding()
        self.setTabStyle()
        self.setEdgeStyle()
        self.setCaretStyle()
        self.setViewEOL()
        self.setWhitespace()
        self.SetZoom(self.locals.font_zoom)
        
        # Added call to colourise because some parameter might have changed
        # that requires a styling update.  E.g.  if the tab highlighting style
        # has changed.
        self.Colourise(0, self.GetTextLength())

    def setWordWrap(self, enable=None, style=None):
        if enable is not None:
            self.locals.wrapping = enable
        if style is not None:
            self.locals.word_wrap = style
        if self.locals.wrapping:
            if self.locals.word_wrap:
                self.SetWrapMode(wx.stc.STC_WRAP_WORD)
            else:
                self.SetWrapMode(wx.stc.STC_WRAP_CHAR)
            self.SetWrapVisualFlags(wx.stc.STC_WRAPVISUALFLAG_END)
        else:
            self.SetWrapMode(wx.stc.STC_WRAP_NONE)

    def setLineNumbers(self,enable=None):
        if enable is not None:
            self.locals.line_numbers=enable
        if self.locals.line_numbers:
            self.SetMarginType(0, wx.stc.STC_MARGIN_NUMBER)
            self.SetMarginWidth(0, self.locals.line_number_margin_width)
        else:
            self.SetMarginWidth(0, 0)
        self.SetMarginMask(0, ~wx.stc.STC_MASK_FOLDERS)
        self.MarkerDefine(self.bookmark_marker_number, wx.stc.STC_MARK_ARROWS)

    def setFolding(self,enable=None):
        if enable is not None:
            self.locals.folding=enable
        if self.locals.folding:
            self.SetMarginType(2, wx.stc.STC_MARGIN_SYMBOL)
            self.SetMarginMask(2, wx.stc.STC_MASK_FOLDERS)
            self.SetMarginSensitive(2, True)
            self.SetMarginWidth(2, self.locals.folding_margin_width)
            #self.Bind(wx.stc.EVT_STC_MARGINCLICK, self.OnMarginClick)
        else:
            self.SetMarginWidth(2, 0)
            #self.Unbind(wx.stc.EVT_STC_MARGINCLICK)

    def OnMarginClick(self, evt):
        lineClicked = self.LineFromPosition(evt.GetPosition())
        if evt.GetMargin() == 0:
            # FIXME: This doesn't actually work because I don't want to make
            # margin 0 sensitive.  Making it sensitive then requires managing
            # all the selection stuff myself.  But, don't want to add margin 1
            # unnecessarily...  A conundrum.
            self.MarkerAdd(lineClicked, self.bookmark_marker_number)
        elif evt.GetMargin() == 2:
            # handle folding and unfolding
            if evt.GetShift() and evt.GetControl():
                self.FoldAll()
            else:
                lineClicked = self.LineFromPosition(evt.GetPosition())
                if self.GetFoldLevel(lineClicked) & wx.stc.STC_FOLDLEVELHEADERFLAG:
                    if evt.GetShift():
                        self.SetFoldExpanded(lineClicked, True)
                        self.Expand(lineClicked, True, True, 1)
                    elif evt.GetControl():
                        if self.GetFoldExpanded(lineClicked):
                            self.SetFoldExpanded(lineClicked, False)
                            self.Expand(lineClicked, False, True, 0)
                        else:
                            self.SetFoldExpanded(lineClicked, True)
                            self.Expand(lineClicked, True, True, 100)
                    else:
                        self.ToggleFold(lineClicked)

    def setTabStyle(self):
        self.SetIndentationGuides(self.locals.indentation_guides)
        self.SetIndent(self.locals.indent_size)
        self.SetTabWidth(self.locals.tab_size)
        self.SetProperty('tab.timmy.whinge.level', str(self.locals.tab_highlight_style))
        self.SetUseTabs(self.locals.use_tab_characters)

    def setEdgeStyle(self):
        self.SetEdgeMode(self.locals.edge_indicator)
        if self.locals.edge_indicator == wx.stc.STC_EDGE_NONE:
            self.SetEdgeColumn(0)
        else:
            self.SetEdgeColumn(self.locals.edge_column)

    def setCaretStyle(self):
        self.SetCaretPeriod(self.locals.caret_blink_rate)
        self.SetCaretLineVisible(self.locals.caret_line_highlight)
        self.SetCaretWidth(self.locals.caret_width)

    def setViewEOL(self, enable=None):
        if enable is not None:
            self.locals.view_eol = enable
        self.SetViewEOL(self.locals.view_eol)
    
    def setWhitespace(self):
        self.SetViewWhiteSpace(self.locals.view_whitespace)
    
    # Map the STC function to the local variable name so the local variables
    # can be properly updated to whatever VIM or EMACS set them to
    stc_to_local_mapping = {
        'Indent': 'indent_size',
        'TabWidth': 'tab_size',
        'UseTabs': 'use_tab_characters',
        'EdgeColumn': 'edge_column',
        'CaretWidth': 'caret_width',
        'CaretLineVisible': 'caret_line_indicator',
        'ViewWhiteSpace': 'view_whitespace',
        }
    
    def applyFileLocalComments(self, text=None):
        if text is None:
            lines = self.scanFileLocalComments()
        else:
            lines = text.splitlines()
        settings = vim.applyVIMModeline(self, lines)
        emacs_settings, emacs_locals = emacs.applyEmacsFileLocalSettings(self)
        settings.extend(emacs_settings)
        kate_settings, kate_locals = kate.applyKateVariables(self, lines)
        settings.extend(kate_settings)
        
        for setting in settings:
            if setting in self.stc_to_local_mapping:
                value = getattr(self, "Get%s" % setting)()
                #dprint("Setting %s to %s" % (mapping[setting], value))
                setattr(self.locals, self.stc_to_local_mapping[setting], value)

    def scanFileLocalComments(self):
        """Scan the first several and last several lines for file-local
        comments.
        
        File local comments contain information about settings that only apply
        to the current file.  In an attempt to be compatible with Emacs, VIM,
        and Kate, groups of lines are considered at the beginning and ending
        of the file.  (The number of lines is controlled by the parameter
        vim_settings_lines)
        """
        start = min(self.GetLineCount(), self.classprefs.vim_settings_lines)
        lines = range(0, start)
        ending = max(start, self.GetLineCount() - self.classprefs.vim_settings_lines)
        lines.extend(range(ending, self.GetLineCount()))
        text = []
        for linenum in lines:
            line = self.GetLine(linenum)
            match = self.comment_regex.match(line)
            if match.group(1).endswith(self.start_line_comment):
                #dprint("line %d: %s" % (linenum, str(match.groups())))
                text.append(line)
        return text
    
    def getTextFileLocalComments(self):
        """Get a text version of the file local comments"""
        text = kate.serializeKateVariables(self)
        return text

    
    ##### Styling code
    
    def braceHighlight(self):
        """Highlight matching braces or flag mismatched braces.
        
        Code taken from StyledTextCtrl_2 from the wxPython demo.  Should
        probably implement this as a dynamic method of the text control or
        the Major Mode, controllable by a setting.
        """
        # check for matching braces
        braceAtCaret = -1
        braceOpposite = -1
        braceStyle = None
        charBefore = None
        caretPos = self.GetCurrentPos()

        # check before
        if caretPos > 0:
            charBefore = self.GetCharAt(caretPos - 1)
            braceStyle = self.GetStyleAt(caretPos - 1)
            #dprint("before: char=%s style=%d" % (charBefore, braceStyle))

            if charBefore and chr(charBefore) in "[]{}()":
                braceAtCaret = caretPos - 1

        # check after
        if braceAtCaret < 0:
            charAfter = self.GetCharAt(caretPos)
            braceStyle = self.GetStyleAt(caretPos)
            #dprint("after: char=%s style=%d" % (charAfter, braceStyle))

            if charAfter and chr(charAfter) in "[]{}()":
                braceAtCaret = caretPos

        if braceAtCaret >= 0:
            braceOpposite = self.BraceMatch(braceAtCaret)

        if braceAtCaret != -1  and braceOpposite == -1:
            self.BraceBadLight(braceAtCaret)
        else:
            if braceStyle != self.GetStyleAt(braceOpposite):
                self.BraceBadLight(braceAtCaret)
            else:
                self.BraceHighlight(braceAtCaret, braceOpposite)

    def OnUpdateUI(self, evt):
        """Specific OnUpdateUI callback for those modes that use an actual
        STC for their edit window.
        
        Adds things like fold level and style display.
        """
        self.braceHighlight()
        assert self.dprint("OnUpdateUI for view %s, frame %s" % (self.keyword,self.frame))
        linenum = self.GetCurrentLine()
        pos = self.GetCurrentPos()
        col = self.GetColumn(pos)
        status = "L%d C%d F%d S%d %d" % (linenum+self.classprefs.line_number_offset,
            col+self.classprefs.column_number_offset,
            self.GetFoldLevel(linenum)&wx.stc.STC_FOLDLEVELNUMBERMASK - wx.stc.STC_FOLDLEVELBASE,
            self.GetStyleAt(pos), pos)
        
        # FIXME: workaround for bug #552: on OSX, setting the status bar inside
        # an event handler apparently generates CGContextRestoreGState errors.
        # Using a CallAfter works around this issue.  I wonder if it would
        # be better to put this in an idle event handler? More testing will
        # probably have to wait until after I get a mac.
        wx.CallAfter(self.frame.SetStatusText, status, 1)
        self.OnUpdateUIHook(evt)
        if evt is not None:
            evt.Skip()

    ##### Comment handling
    def createCommentRegex(self):
        """Set class-specific comment regex
        
        A regex is created that will match a line with the comment characters.
        The regex returns a 3-tuple of whitespace followed by the opening
        comment character, the body of the line, and then the closing comment
        including any trailing whitespace.  If the language doesn't have a
        closing comment character, the final tuple element will always be
        an empty string.
        """
        cache = self.getClassCache()
        try:
            self.comment_regex = cache['comment_regex']
        except KeyError:
            start = self.start_line_comment
            end = self.end_line_comment
            if start:
                #if isinstance(start, list) or isinstance(start, tuple):
                if self.start_line_comment_list:
                    # multiple comment start characters are permitted
                    part1 = "\\" + "|\\".join(["\\".join(a) for a in self.start_line_comment_list])
                else:
                    part1 = "\\" + "\\".join(start)
                if end:
                    part2 = "\\" + "\\".join(end)
                    regex = r"^(\s*(?:%s)*)(.*?)((?:%s)*\s*$)" % (part1, part2)
                else:
                    regex = r"^(\s*(?:%s)*)(.*)($)" % part1
                self.dprint(regex)
                self.comment_regex = re.compile(regex)
            else:
                regex = r"^(\s*)(.*)($)"
                self.dprint(regex)
                self.comment_regex = re.compile(regex)
            cache['comment_regex'] = self.comment_regex
        
    def commentRegion(self, add=True):
        """Default implementation of block commenting and uncommenting
    
        This class provides the default implementation of block commenting.
        Blocks are commented by adding a comment string at the beginning of
        the line, and an optional comment string at the end of each line in
        the block.
    
        Typically the comment characters are known to the Editra styling system
        and are therefore automatically added to the FundamentalMode subclass
        by a call to L{setCommentDelimiters}.

        @param add: True to add comments, False to remove them
        """
        eol_len = len(self.getLinesep())
        if add:
            func = self.addLinePrefixAndSuffix
        else:
            func = self.removeLinePrefixAndSuffix
        
        self.BeginUndoAction()
        line, lineend = self.GetLineRegion()
        assert self.dprint("lines: %d - %d" % (line, lineend))
        try:
            selstart, selend = self.GetSelection()
            assert self.dprint("selection: %d - %d" % (selstart, selend))

            start = selstart
            end = self.GetLineEndPosition(line)
            while line <= lineend:
                start = func(start, end, self.start_line_comment, self.end_line_comment)
                line += 1
                end = self.GetLineEndPosition(line)
            self.SetSelection(selstart, start - eol_len)
        finally:
            self.EndUndoAction()
            
    def splitCommentLine(self, line, info=None):
        """Split the line into the whitespace leader and body of the line.
        
        Return a tuple containing the leading whitespace and comment
        character(s), the body of the line, and any trailing comment
        character(s)
        
        @param info: optional ParagraphInfo object to allow subclasses to have
        access to the object.
        """
        match = self.comment_regex.match(line)
        if match is None:
            return ("", line, "")
        self.dprint(match.groups())
        return match.group(1, 2, 3)


    ##### Paragraphs
    def findParagraph(self, start, end=-1):
        """Return a ParagraphInfo object from the current paragraph.
        
        A paragraph is defined as either: 1) a group of lines delimited by
        lines that only contain whitespace, or 2) a group of lines that share
        a common prefix.
        
        The details of defining the paragraph are left up to the major mode's
        associated paragraph class to generate a paragraph info object.
        """
        info = self.paragraph_cls(self, start, end)
        return info


    ##### Code folding for function lists
    def OnFoldChanged(self, evt):
        """Callback to process fold events.
        
        This callback is initiated from within the event handler of PeppySTC.
        The events could be used to optimize the fold algorithm, but
        currently this data is not used by anything.
        """
        stc_class_info = self.getSharedClassInfo(self.__class__)
        if 'fold_hierarchy' in stc_class_info:
            #dprint("changed fold at line=%d, pos=%d" % (evt.Line, evt.Position))
            stc_class_info['fold_changed'].append(evt.Line)
            self.sendMessageWhenIdle('fold_changed', mode=self)
    
    def getFoldHierarchy(self):
        """Get the current fold hierarchy, returning the existing copy if there
        are no changes, or updating if necessary.
        """
        stc_class_info = self.getSharedClassInfo(self.__class__)
        if 'fold_hierarchy' not in stc_class_info or stc_class_info['fold_changed'] or self.GetLineCount() != stc_class_info['fold_line_count']:
            #dprint("Fold hierarchy has changed.  Updating.")
            self.updateFoldHierarchy()
        fold_hier = stc_class_info['fold_hierarchy']
        return fold_hier

    def updateFoldHierarchy(self):
        """Create the fold hierarchy using Stani's fold explorer algorithm.

        Scintilla's folding code is used to generate the function lists in
        some major modes.  Scintilla doesn't support code folding in all its
        supported languages, so major modes that aren't supported may mimic
        this interface to provide similar functionality.
        """
        # FIXME: Turn this into a threaded operation if it takes too long
        t = time.time()
        self.Colourise(0, self.GetTextLength())
        self.dprint("Finished colourise: %0.5f" % (time.time() - t))
        
        # Note that different views of the same buffer *using the same major
        # mode* will have the same fold hierarchy.  So, we use the stc's
        # getSharedClassInfo interface to store data common to all views of
        # this buffer that use this major mode.
        stc_class_info = self.getSharedClassInfo(self.__class__)
        new_folds = self.computeFoldHierarchy()
        
        # Attempt to copy the tree expansion from the old tree to the new one
        if 'fold_hierarchy' in stc_class_info:
            old_folds = stc_class_info['fold_hierarchy']
            self.copyFoldHierarchyTreeExpansion(old_folds, new_folds)
            
        stc_class_info['fold_hierarchy'] = new_folds
        stc_class_info['fold_changed'] = []
        
        # Note: folding events aren't fired when only blank lines are inserted
        # or deleted, so we keep track of the line count as a secondary method
        # to indicate the folding needs to be recalculated
        stc_class_info['fold_line_count'] = self.GetLineCount()
        
        return stc_class_info['fold_hierarchy']
    
    def getFoldEntryFunctionName(self, line):
        """Check if line should be included in a list of functions.
        
        Used as callback function by the fold explorer mixin: if the line should
        be included in a list of functions, return True here.  Because the
        scintilla folding includes a lot of other data than function calls, we
        have to cull the full list to only include lines that we want.
        
        @param line: line number of the fold entry
        
        @return: text string that should be used as function name, or "" if it
        should be skipped in the function menu
        """
        return ""


    ### Spell checking utilities
    def setSpelling(self):
        spelling_classes = []
        Publisher().sendMessage('spelling.provider', spelling_classes)
        if spelling_classes:
            self.spell = spelling_classes[0](self, check_region=self.isSpellCheckRegion)
            self.spell.clearAll()
            if self.classprefs.spell_check:
                self.spell.startIdleProcessing()

    def spellCheckUpdate(self, evt):
        if self.spell:
            mod = evt.GetModificationType()
            if mod & wx.stc.STC_MOD_INSERTTEXT or mod & wx.stc.STC_MOD_DELETETEXT:
                pos = evt.GetPosition()
                last = pos + evt.GetLength()
                self.spell.addDirtyRange(pos, last, evt.GetLinesAdded(), mod & wx.stc.STC_MOD_DELETETEXT)
    
    def getPopupActions(self, evt, x, y):
        pos = self.PositionFromPoint(wx.Point(x, y))
        # Save the word that should be spell-checked so that the spell checking
        # action won't have to figure out which word to check
        self.check_spelling = self.getWordFromPosition(pos)
        #dprint(self.check_spelling)
        action_classes = []
        Publisher().sendMessage('fundamental.context_menu', action_classes)
        return action_classes

    def idlePostHook(self):
        if self.spell and self.classprefs.spell_check:
            try:
                self.spell.processIdleBlock()
            except Exception, e:
                import traceback
                error = traceback.format_exc()
                print(error)
                print("Problem with %s.  Turning off spell checking." % self.spell.getLibraryInfo())
                self.spell = None
        if self.calltip_driver:
            self.showCalltip()
    
    def isSpellCheckRegion(self, pos):
        if self.classprefs.spell_check_strings_only:
            style = self.GetStyleAt(pos)
            return self.isStyleComment(style) or self.isStyleString(style)
        return True

    def updateRegion(self, start, end):
        self.Colourise(start, end)
        if self.spell:
            self.spell.checkRange(start, end)


    ## Printing
    def isPrintingSupported(self):
        """Returns True if possible to print the current view of the major
        mode.
        """
        return True
    
    def getPrintout(self, data):
        """Returns a wx.Printout object that the printer management driver
        can use to generate a print preview or a paper copy.
        
        """
        import peppy.lib.stcprint
        return peppy.lib.stcprint.STCPrintout(self, page_setup_data=data, title=str(self.buffer.url))
    
    ## STC Calltips
    def showCalltip(self):
        """Driver to show calltips using the STC's built-in calltips
        
        """
        pos = self.GetCurrentPos()
        show_pos = self.getCalltipPos(pos)
        if show_pos != self.calltip_pos:
            if self.calltip_pos >= 0 and self.CallTipActive():
                self.CallTipCancel()
            self.CallTipSetBackground("yellow")
            dprint("New calltip at %d" % show_pos)
            text = self.getCalltipText(pos)
            if text:
                self.CallTipShow(show_pos, text)
                self.calltip_pos = show_pos
            else:
                self.calltip_pos = -1
    
    def getCalltipPos(self, pos):
        """Routine to modify the calltip display pos if necessary.
        
        For example, you may want the calltip to display from the start of the
        word, rather than the current cursor position within the word.
        """
        return pos
    
    def getCalltipText(self, pos):
        """The text to be displayed in the calltip
        
        Note that the STC requires the calltip text to use LF (\n) line
        endings only, not windows (\r\n) line endings, even when on windows
        platforms
        
        @returns text to display in calltip, or empty string if no calltip
        should be displayed.
        """
        return ""
