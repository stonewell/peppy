# peppy Copyright (c) 2006-2010 Rob McMullen
# Licenced under the GPLv2; see http://peppy.flipturn.org for more info
"""Localization utilities for peppy

The i18n concepts here are a combination of the locale support from
U{TaskCoach<http://www.taskcoach.org} and U{Editra<http://www.editra.org}.

From TaskCoach I've borrowed the idea that message catalogs are
stored in python dictionaries, not gettext C{.po} files.  Gettext
C{.po} files are used to create the message catalogs and in U{Launchpad
Translations<https://translations.launchpad.net/peppy>}, but they are then run
through a preprocessor to generate the python dicts that are distributed with
the program.

From Editra I've borrowed some code in the L{createTranslationMap} method and
the L{LangListCombo} control.
"""

import wx
import wx.lib.langlistctrl as langlist
import wx.combo

try:
    from peppy_message_catalogs import *
except ImportError:
    supplied_translations = ['en_US']

class LocaleDetails(object):
    """Storage for locale info.
    
    Simple class used to store wx language identifier, the canonical name of
    the locale, and a user-friendly description.
    """
    def __init__(self, lang, canonical, description):
        self.lang_id = lang
        self.canonical = canonical
        self.description = description
    
    def __str__(self):
        return "id=%d canonical=%s description=%s" % (self.lang_id, self.canonical,
                                                      self.description)

def createTranslationMap(loc_list):
    """Create a mapping from catalog name to locale details.
    
    Scans the wx locale data to determine the wx language ID and plain-text
    description that can be used in the user interface to choose the language.
    
    The catalog names are passed in as a list, and may contain either the
    language and country, or just the language.  If it's just the language,
    the first match in the wx language list is returned.  On my machine,
    for instance, there is no match for only the "ru" locale -- it's either
    'ru_RU' for Russia or 'ru_UA' for the Ukrainian dialect of Russian.  So,
    because "ru_RU" appears first in the list, that will be used for "ru".
    
    Heavily modified from the Editra source.
    """
    lang_dict = {}
    already_seen = {}
    for lang in [x for x in dir(wx) if x.startswith("LANGUAGE")]:
        loc_i = wx.Locale(wx.LANGUAGE_DEFAULT).\
                          GetLanguageInfo(getattr(wx, lang))
        if loc_i:
            canonical = loc_i.CanonicalName
            if canonical in loc_list:
                lang_dict[canonical] = LocaleDetails(getattr(wx, lang),
                                                     canonical, loc_i.Description)
            elif '_' in canonical:
                country = canonical[0:2]
                if country in loc_list and not country in already_seen:
                    lang_dict[country] = LocaleDetails(getattr(wx, lang),
                                                       canonical, loc_i.Description)
                    already_seen[country] = True
    return lang_dict

translation_map = None
description_map = None
def getTranslationMap():
    """Convenience function to create the translation map and description map
    
    The translation map is generated by L{createTranslationMap}, and is then
    used to create another mapping from the user-friendly name of the locale
    to the catalog name.
    """
    global translation_map
    global description_map
    
    if translation_map is None:
        translation_map = createTranslationMap(supplied_translations)
        #print translation_map
        description_map = {}
        for catalog in translation_map:
            description_map[translation_map[catalog].description] = catalog
        #print description_map
    return translation_map

def importCatalog(catalog):
    """Attempt to load the message catalog.
    
    Message catalogs used in peppy are dictionaries generated from gettext
    .po files.  The .po files are pre-compiled into the dictionaries and
    stored in modules in this directory named as the message catalog name.
    If the import of the catalog succeeds, the dict and its encoding will be
    returned; otherwise a blank dict is returned.
    """
    try: 
        module = __import__(catalog, globals())
        return (module.dict, module.encoding)
    except ImportError:
        pass
    return ({}, 'utf-8')

class LangListCombo(wx.combo.BitmapComboBox):
    """Combines a langlist and a BitmapComboBox
    
    Borrowed and modified from Editra.
    """
    
    def __init__(self, parent, id=-1, default=None, langs=[]):
        """Creates a combobox with a list of all translations for the
        editor as well as displaying the countries flag next to the item
        in the list.

        @param default: The default item to show in the combo box

        """
        lang_ids = [t.lang_id for t in getTranslationMap().values()]
        #print lang_ids
        lang_items = langlist.CreateLanguagesResourceLists(langlist.LC_ONLY, \
                                                           lang_ids)
        #print lang_items
        wx.combo.BitmapComboBox.__init__(self, parent, id, 
                                         size=wx.Size(250, 26), 
                                         style=wx.CB_READONLY)
        for lang_d in lang_items[1]:
            bit_m = lang_items[0].GetBitmap(lang_items[1].index(lang_d))
            self.Append(lang_d, bit_m)

        if default:
            if default in translation_map:
                self.SetValue(translation_map[default].description)
    
    def setCatalog(self, locale):
        if locale in translation_map:
            self.SetValue(translation_map[locale].description)
    
    def getCatalog(self):
        #print self.GetValue()
        text = self.GetValue()
        
        # SUSE linux localized in German seems to prefix the langauge with
        # "Default:"
        if text.startswith("Default:"):
            text = text[8:].strip()
        
        #print description_map[text]
        return description_map[text]

if __name__ == '__main__':
    class MyFrame(wx.Frame):
        def __init__(self, parent, id, title):
            wx.Frame.__init__(self, parent, id, title, wx.DefaultPosition, wx.DefaultSize)
            panel = wx.Panel(self)
            sizer = wx.BoxSizer(wx.VERTICAL)
            panel.SetSizer(sizer)
            self.langs = LangListCombo(panel, langs=supplied_translations, default="en_US")
            sizer.Add(self.langs, 0, wx.EXPAND)
            btn = wx.Button(panel, wx.ID_OK, label="Show Catalog Name")
            sizer.Add(btn, 0, wx.EXPAND)
            btn.Bind(wx.EVT_BUTTON, self.OnShow)
            sizer.Fit(panel)
            panel.Layout()
        
        def OnShow(self, evt):
            catalog = self.langs.getCatalog()
            print("Selected %s" % catalog)

    class MyApp(wx.App):
        def OnInit(self):
            frame = MyFrame(None, -1, 'Peppy Languages.py')
            frame.Show(True)
            frame.Centre()
            return True

    APP = wx.PySimpleApp(False)
    # Print a list of Cannonical names usefull for seeing what codes to
    # use when naming po files
    for LANG in [x for x in dir(wx) if x.startswith("LANGUAGE")]:
        lang_id = getattr(wx, LANG)
        LOC_I = wx.Locale(wx.LANGUAGE_DEFAULT).\
                         GetLanguageInfo(lang_id)
        if LOC_I:
            print lang_id, LOC_I.CanonicalName, LOC_I.Description

    app = MyApp(0)
    app.MainLoop()
